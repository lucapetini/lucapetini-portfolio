{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-cpp.js"],"sourcesContent":["(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:import|module)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n"],"names":[],"mappings":"AAAC,CAAA,SAAU,MAAK;IAEf,IAAI,UAAU;IACd,IAAI,UAAU,uCAAuC,MAAM,CAAC,OAAO,CAAC,cAAc;QAAc,OAAO,QAAQ,MAAM;IAAE;IAEvH,OAAM,SAAS,CAAC,GAAG,GAAG,OAAM,SAAS,CAAC,MAAM,CAAC,KAAK;QACjD,cAAc;YACb;gBACC,SAAS,OAAO,gEAAgE,MAAM,CACpF,OAAO,CAAC,cAAc;oBAAc,OAAO,QAAQ,MAAM;gBAAE;gBAC7D,YAAY;YACb;YACA,6EAA6E;YAC7E,6BAA6B;YAC7B,0GAA0G;YAC1G,qFAAqF;YACrF;YACA,4DAA4D;YAC5D,mBAAmB;YACnB;YACA,wGAAwG;YACxG,8EAA8E;YAC9E;SACA;QACD,WAAW;QACX,UAAU;YACT,SAAS;YACT,QAAQ;QACT;QACA,YAAY;QACZ,WAAW;IACZ;IAEA,OAAM,SAAS,CAAC,YAAY,CAAC,OAAO,UAAU;QAC7C,UAAU;YACT,qDAAqD;YACrD,SAAS,OACR,2BAA2B,MAAM,GACjC,QACA,cAAc;YACd,mDAAmD,MAAM,GACzD,MACA,mCAAmC;YACnC,kDAAkD,MAAM,CAAC,OAAO,CAAC,eAAe;gBAAc,OAAO;YAAS,KAC9G;YAED,YAAY;YACZ,QAAQ;YACR,QAAQ;gBACP,UAAU;gBACV,YAAY;gBACZ,eAAe;YAChB;QACD;QACA,cAAc;YACb,SAAS;YACT,OAAO;YACP,QAAQ;QACT;IACD;IAEA,OAAM,SAAS,CAAC,YAAY,CAAC,OAAO,WAAW;QAC9C,oBAAoB;YACnB,SAAS;YACT,QAAQ;gBACP,YAAY;gBACZ,WAAW;oBACV,SAAS;oBACT,OAAO;oBACP,QAAQ,OAAM,SAAS,CAAC,GAAG;gBAC5B;YACD;QACD;IACD;IAEA,OAAM,SAAS,CAAC,YAAY,CAAC,OAAO,YAAY;QAC/C,gBAAgB;YACf,SAAS;YACT,OAAO;QACR;IACD;IAEA,OAAM,SAAS,CAAC,YAAY,CAAC,OAAO,cAAc;QACjD,wDAAwD;QACxD,mDAAmD;QACnD,eAAe;YACd,SAAS;YACT,YAAY;YACZ,QAAQ;YACR,QAAQ,OAAM,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC;QACxC;IACD;IAEA,OAAM,SAAS,CAAC,YAAY,CAAC,UAAU,gBAAgB;QACtD,sEAAsE;QACtE,cAAc;IACf,GAAG,OAAM,SAAS,CAAC,GAAG,CAAC,cAAc;AAEtC,CAAA,EAAE","ignoreList":[0]}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-zig.js"],"sourcesContent":["(function (Prism) {\n\n\tfunction literal(str) {\n\t\treturn function () { return str; };\n\t}\n\n\tvar keyword = /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n\n\tvar IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n\tvar ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n\tvar PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n\tvar SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n\tvar TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n\n\t/*\n\t * A simplified grammar for Zig compile time type literals:\n\t *\n\t * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n\t *\n\t * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n\t *\n\t * PREFIX_TYPE_OP = \"?\"\n\t *                | \\b \"promise\" \"->\"\n\t *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n\t *\n\t * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n\t *\n\t * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n\t *\n\t*/\n\n\tPrism.languages.zig = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: /\\/\\/[/!].*/,\n\t\t\t\talias: 'doc-comment'\n\t\t\t},\n\t\t\t/\\/{2}.*/\n\t\t],\n\t\t'string': [\n\t\t\t{\n\t\t\t\t// \"string\" and c\"string\"\n\t\t\t\tpattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// multiline strings and c-strings\n\t\t\t\tpattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'char': {\n\t\t\t// characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n\t\t\tpattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t'builtin': /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n\t\t'label': {\n\t\t\tpattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'class-name': [\n\t\t\t// const Foo = struct {};\n\t\t\t/\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n\t\t\t{\n\t\t\t\t// const x: i32 = 9;\n\t\t\t\t// var x: Bar;\n\t\t\t\t// fn foo(x: bool, y: f32) void {}\n\t\t\t\tpattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t{\n\t\t\t\t// extern fn foo(x: f64) f64; (optional alignment)\n\t\t\t\tpattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: null // see below\n\t\t\t}\n\t\t],\n\t\t'builtin-type': {\n\t\t\tpattern: /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n\t\t\talias: 'keyword'\n\t\t},\n\t\t'keyword': keyword,\n\t\t'function': /\\b(?!\\d)\\w+(?=\\s*\\()/,\n\t\t'number': /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'operator': /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n\t\t'punctuation': /[.:,;(){}[\\]]/\n\t};\n\n\tPrism.languages.zig['class-name'].forEach(function (obj) {\n\t\tif (obj.inside === null) {\n\t\t\tobj.inside = Prism.languages.zig;\n\t\t}\n\t});\n\n}(Prism));\n"],"names":[],"mappings":"AAAC,CAAA,SAAU,MAAK;IAEf,SAAS,QAAQ,GAAG;QACnB,OAAO;YAAc,OAAO;QAAK;IAClC;IAEA,IAAI,UAAU;IAEd,IAAI,aAAa,WAAW,QAAQ,MAAM,GAAG;IAC7C,IAAI,QAAQ,oCAAoC,MAAM;IACtD,IAAI,iBAAiB,0GAA0G,MAAM,CAAC,OAAO,CAAC,YAAY,QAAQ;IAClK,IAAI,cAAc,2DAA2D,MAAM,CAAC,OAAO,CAAC,SAAS,QAAQ;IAC7G,IAAI,OAAO,wBAAwB,iBAAiB,WAAW,cAAc;IAE7E;;;;;;;;;;;;;;;CAeA,GAEA,OAAM,SAAS,CAAC,GAAG,GAAG;QACrB,WAAW;YACV;gBACC,SAAS;gBACT,OAAO;YACR;YACA;SACA;QACD,UAAU;YACT;gBACC,yBAAyB;gBACzB,SAAS;gBACT,YAAY;gBACZ,QAAQ;YACT;YACA;gBACC,kCAAkC;gBAClC,SAAS;gBACT,YAAY;gBACZ,QAAQ;YACT;SACA;QACD,QAAQ;YACP,6CAA6C;YAC7C,SAAS;YACT,YAAY;YACZ,QAAQ;QACT;QACA,WAAW;QACX,SAAS;YACR,SAAS;YACT,YAAY;QACb;QACA,cAAc;YACb,yBAAyB;YACzB;YACA;gBACC,oBAAoB;gBACpB,cAAc;gBACd,kCAAkC;gBAClC,SAAS,OAAO,0EAA0E,MAAM,CAAC,OAAO,CAAC,WAAW,QAAQ,OAAO,OAAO,CAAC,YAAY,QAAQ;gBAC/J,YAAY;gBACZ,QAAQ,KAAK,YAAY;YAC1B;YACA;gBACC,kDAAkD;gBAClD,SAAS,OAAO,uCAAuC,MAAM,CAAC,OAAO,CAAC,WAAW,QAAQ,OAAO,OAAO,CAAC,YAAY,QAAQ;gBAC5H,YAAY;gBACZ,QAAQ,KAAK,YAAY;YAC1B;SACA;QACD,gBAAgB;YACf,SAAS;YACT,OAAO;QACR;QACA,WAAW;QACX,YAAY;QACZ,UAAU;QACV,WAAW;QACX,YAAY;QACZ,eAAe;IAChB;IAEA,OAAM,SAAS,CAAC,GAAG,CAAC,aAAa,CAAC,OAAO,CAAC,SAAU,GAAG;QACtD,IAAI,IAAI,MAAM,KAAK,MAAM;YACxB,IAAI,MAAM,GAAG,OAAM,SAAS,CAAC,GAAG;QACjC;IACD;AAED,CAAA,EAAE","ignoreList":[0]}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-nim.js"],"sourcesContent":["Prism.languages.nim = {\n\t'comment': {\n\t\tpattern: /#.*/,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)\n\t\tpattern: /(?:\\b(?!\\d)(?:\\w|\\\\x[89a-fA-F][0-9a-fA-F])+)?(?:\"\"\"[\\s\\S]*?\"\"\"(?!\")|\"(?:\\\\[\\s\\S]|\"\"|[^\"\\\\])*\")/,\n\t\tgreedy: true\n\t},\n\t'char': {\n\t\t// Character literals are handled specifically to prevent issues with numeric type suffixes\n\t\tpattern: /'(?:\\\\(?:\\d+|x[\\da-fA-F]{0,2}|.)|[^'])'/,\n\t\tgreedy: true\n\t},\n\n\t'function': {\n\t\tpattern: /(?:(?!\\d)(?:\\w|\\\\x[89a-fA-F][0-9a-fA-F])+|`[^`\\r\\n]+`)\\*?(?:\\[[^\\]]+\\])?(?=\\s*\\()/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'operator': /\\*$/\n\t\t}\n\t},\n\t// We don't want to highlight operators (and anything really) inside backticks\n\t'identifier': {\n\t\tpattern: /`[^`\\r\\n]+`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'punctuation': /`/\n\t\t}\n\t},\n\n\t// The negative look ahead prevents wrong highlighting of the .. operator\n\t'number': /\\b(?:0[xXoObB][\\da-fA-F_]+|\\d[\\d_]*(?:(?!\\.\\.)\\.[\\d_]*)?(?:[eE][+-]?\\d[\\d_]*)?)(?:'?[iuf]\\d*)?/,\n\t'keyword': /\\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\\b/,\n\t'operator': {\n\t\t// Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)\n\t\t// but allow the slice operator .. to take precedence over them\n\t\t// One can define his own operators in Nim so all combination of operators might be an operator.\n\t\tpattern: /(^|[({\\[](?=\\.\\.)|(?![({\\[]\\.).)(?:(?:[=+\\-*\\/<>@$~&%|!?^:\\\\]|\\.\\.|\\.(?![)}\\]]))+|\\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\\b)/m,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /[({\\[]\\.|\\.[)}\\]]|[`(){}\\[\\],:]/\n};\n"],"names":[],"mappings":"AAAA,MAAM,SAAS,CAAC,GAAG,GAAG;IACrB,WAAW;QACV,SAAS;QACT,QAAQ;IACT;IACA,UAAU;QACT,2FAA2F;QAC3F,SAAS;QACT,QAAQ;IACT;IACA,QAAQ;QACP,2FAA2F;QAC3F,SAAS;QACT,QAAQ;IACT;IAEA,YAAY;QACX,SAAS;QACT,QAAQ;QACR,QAAQ;YACP,YAAY;QACb;IACD;IACA,8EAA8E;IAC9E,cAAc;QACb,SAAS;QACT,QAAQ;QACR,QAAQ;YACP,eAAe;QAChB;IACD;IAEA,yEAAyE;IACzE,UAAU;IACV,WAAW;IACX,YAAY;QACX,0FAA0F;QAC1F,+DAA+D;QAC/D,gGAAgG;QAChG,SAAS;QACT,YAAY;IACb;IACA,eAAe;AAChB","ignoreList":[0]}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-graphql.js"],"sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /\\b[A-Z]\\w*Input\\b/,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}
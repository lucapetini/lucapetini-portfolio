{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-sml.js"],"sourcesContent":["// https://smlfamily.github.io/sml97-defn.pdf\n// https://people.mpi-sws.org/~rossberg/sml.html\n(function (Prism) {\n\n\tvar keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n\n\tPrism.languages.sml = {\n\t\t// allow one level of nesting\n\t\t'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n\t\t'string': {\n\t\t\tpattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\t// This is only an approximation since the real grammar is context-free\n\t\t\t\t//\n\t\t\t\t// Why the main loop so complex?\n\t\t\t\t// The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n\t\t\t\t// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n\t\t\t\t// followed by a long identifier.\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\t/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source\n\t\t\t\t\t\t.replace(/<NOT-LAST>/g, function () { return /\\s*(?:[*,]|->)/.source; })\n\t\t\t\t\t\t.replace(/<TERMINAL>/g, function () {\n\t\t\t\t\t\t\treturn /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.replace(/<LONG-ID>/g, function () { return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source; })\n\t\t\t\t\t\t.replace(/<KEYWORD>/g, function () { return keywords.source; }),\n\t\t\t\t\t'i'\n\t\t\t\t),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'function': {\n\t\t\tpattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t'keyword': keywords,\n\t\t'variable': {\n\t\t\tpattern: /(^|[^\\w'])'[\\w']*/,\n\t\t\tlookbehind: true,\n\t\t},\n\n\t\t'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n\t\t'word': {\n\t\t\tpattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n\t\t\talias: 'constant'\n\t\t},\n\n\t\t'boolean': /\\b(?:false|true)\\b/i,\n\t\t'operator': /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n\t\t'punctuation': /[(){}\\[\\].:,;]/\n\t};\n\n\tPrism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n\n\tPrism.languages.smlnj = Prism.languages.sml;\n\n}(Prism));\n"],"names":[],"mappings":"AAAA,6CAA6C;AAC7C,gDAAgD;AAC/C,CAAA,SAAU,MAAK;IAEf,IAAI,WAAW;IAEf,OAAM,SAAS,CAAC,GAAG,GAAG;QACrB,6BAA6B;QAC7B,WAAW;QACX,UAAU;YACT,SAAS;YACT,QAAQ;QACT;QAEA,cAAc;YACb;gBACC,uEAAuE;gBACvE,EAAE;gBACF,gCAAgC;gBAChC,2GAA2G;gBAC3G,0GAA0G;gBAC1G,iCAAiC;gBACjC,SAAS,OACR,2HAA2H,MAAM,CAC/H,OAAO,CAAC,eAAe;oBAAc,OAAO,iBAAiB,MAAM;gBAAE,GACrE,OAAO,CAAC,eAAe;oBACvB,OAAO,6FAA6F,MAAM;gBAC3G,GACC,OAAO,CAAC,cAAc;oBAAc,OAAO,+BAA+B,MAAM;gBAAE,GAClF,OAAO,CAAC,cAAc;oBAAc,OAAO,SAAS,MAAM;gBAAE,IAC9D;gBAED,YAAY;gBACZ,QAAQ;gBACR,QAAQ,KAAK,YAAY;YAC1B;YACA;gBACC,SAAS;gBACT,YAAY;YACb;SACA;QACD,YAAY;YACX,SAAS;YACT,YAAY;QACb;QAEA,WAAW;QACX,YAAY;YACX,SAAS;YACT,YAAY;QACb;QAEA,UAAU;QACV,QAAQ;YACP,SAAS;YACT,OAAO;QACR;QAEA,WAAW;QACX,YAAY;QACZ,eAAe;IAChB;IAEA,OAAM,SAAS,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE,CAAC,MAAM,GAAG,OAAM,SAAS,CAAC,GAAG;IAEjE,OAAM,SAAS,CAAC,KAAK,GAAG,OAAM,SAAS,CAAC,GAAG;AAE5C,CAAA,EAAE","ignoreList":[0]}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/lucapetini/Desktop/Workspace/Progetti%20Personali/Luca%20Petini/lucapetini-portfolio/node_modules/prismjs/components/prism-js-templates.js"],"sourcesContent":["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:markdown|md)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// sql`...`\n\t\tcreateTemplate('sql', /\\bsql/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}
"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useRef, useEffect, forwardRef, useImperativeHandle, useCallback, } from "react";
import { Row } from ".";
import styles from "./Hover.module.scss";
const Hover = forwardRef(({ trigger, overlay, interactive = false, delay = 0, hideDelay = 0, disabled = false, touch = "disable", ...flex }, ref) => {
    const [isHovered, setIsHovered] = useState(false);
    const [isFocused, setIsFocused] = useState(false);
    const [mounted, setMounted] = useState(false);
    const [isTouchDevice, setIsTouchDevice] = useState(false);
    const wrapperRef = useRef(null);
    const showTimeoutRef = useRef(null);
    const hideTimeoutRef = useRef(null);
    useImperativeHandle(ref, () => wrapperRef.current);
    useEffect(() => {
        setMounted(true);
        setIsTouchDevice("ontouchstart" in window || navigator.maxTouchPoints > 0);
    }, []);
    const showOverlay = useCallback(() => {
        if (disabled)
            return;
        // Clear any pending hide timeout
        if (hideTimeoutRef.current) {
            clearTimeout(hideTimeoutRef.current);
            hideTimeoutRef.current = null;
        }
        if (delay > 0) {
            showTimeoutRef.current = setTimeout(() => {
                setIsHovered(true);
            }, delay);
        }
        else {
            setIsHovered(true);
        }
    }, [delay, disabled]);
    const hideOverlay = useCallback(() => {
        // Clear any pending show timeout
        if (showTimeoutRef.current) {
            clearTimeout(showTimeoutRef.current);
            showTimeoutRef.current = null;
        }
        if (hideDelay > 0) {
            hideTimeoutRef.current = setTimeout(() => {
                setIsHovered(false);
            }, hideDelay);
        }
        else {
            setIsHovered(false);
        }
    }, [hideDelay]);
    const handleMouseEnter = useCallback(() => {
        showOverlay();
    }, [showOverlay]);
    const handleMouseLeave = useCallback(() => {
        hideOverlay();
    }, [hideOverlay]);
    const handleFocus = useCallback(() => {
        setIsFocused(true);
        showOverlay();
    }, [showOverlay]);
    const handleBlur = useCallback(() => {
        setIsFocused(false);
        hideOverlay();
    }, [hideOverlay]);
    // Cleanup timeouts on unmount
    useEffect(() => {
        return () => {
            if (showTimeoutRef.current) {
                clearTimeout(showTimeoutRef.current);
            }
            if (hideTimeoutRef.current) {
                clearTimeout(hideTimeoutRef.current);
            }
        };
    }, []);
    // Determine if overlay should show based on touch mode
    const shouldShowOverlay = (() => {
        if (!mounted || disabled)
            return false;
        // If on touch device, handle based on touch prop
        if (isTouchDevice) {
            if (touch === 'disable')
                return false;
            if (touch === 'display')
                return true;
            // touch === 'enable', fall through to normal hover logic
        }
        return isHovered || isFocused;
    })();
    return (_jsxs(Row, { ref: wrapperRef, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, onFocus: handleFocus, onBlur: handleBlur, ...flex, children: [trigger, shouldShowOverlay && (_jsx(Row, { position: "absolute", pointerEvents: interactive ? "auto" : "none", fill: true, style: {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                }, className: styles.fadeIn, children: overlay }))] }));
});
Hover.displayName = "Hover";
export { Hover };
//# sourceMappingURL=Hover.js.map
"use client";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from "react";
import { Row, Text, CountFx } from ".";
const CountdownFx = ({ targetDate, format = "HH:MM:SS", effect = "wheel", onComplete, ...countFxProps }) => {
    const [timeRemaining, setTimeRemaining] = useState({
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        total: 0,
    });
    useEffect(() => {
        const calculateTimeRemaining = () => {
            const now = new Date().getTime();
            const target = typeof targetDate === 'string' ? new Date(targetDate).getTime() : targetDate.getTime();
            const difference = target - now;
            if (difference <= 0) {
                setTimeRemaining({ days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 });
                if (onComplete) {
                    onComplete();
                }
                return;
            }
            const days = Math.floor(difference / (1000 * 60 * 60 * 24));
            const hours = Math.floor((difference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((difference % (1000 * 60)) / 1000);
            setTimeRemaining({ days, hours, minutes, seconds, total: difference });
        };
        calculateTimeRemaining();
        const interval = setInterval(calculateTimeRemaining, 1000);
        return () => clearInterval(interval);
    }, [targetDate, onComplete]);
    const padZero = (num) => num.toString().padStart(2, '0');
    const renderTimeUnit = (value, key) => {
        const paddedValue = padZero(value);
        const digits = paddedValue.split('');
        return (_jsx(Row, { gap: "0", inline: true, children: digits.map((digit, index) => (_jsx(CountFx, { value: parseInt(digit), effect: effect, speed: 400, ...countFxProps }, `${key}-${index}`))) }, key));
    };
    const renderSeparator = () => (_jsx(Text, { ...countFxProps, style: { width: '0.5em', textAlign: 'center' }, children: ":" }, `sep-${Math.random()}`));
    if (timeRemaining.total === 0) {
        return (_jsxs(Row, { gap: "0", align: "center", textVariant: countFxProps.variant, style: { fontVariantNumeric: 'tabular-nums' }, children: [format === "DD:HH:MM:SS" && (_jsxs(_Fragment, { children: [renderTimeUnit(0, 'days'), renderSeparator()] })), renderTimeUnit(0, 'hours'), renderSeparator(), renderTimeUnit(0, 'minutes'), format !== "MM:SS" && (_jsxs(_Fragment, { children: [renderSeparator(), renderTimeUnit(0, 'seconds')] }))] }));
    }
    return (_jsxs(Row, { gap: "0", align: "center", style: { fontVariantNumeric: 'tabular-nums' }, children: [format === "DD:HH:MM:SS" && timeRemaining.days > 0 && (_jsxs(_Fragment, { children: [renderTimeUnit(timeRemaining.days, 'days'), renderSeparator()] })), format !== "MM:SS" && (_jsxs(_Fragment, { children: [renderTimeUnit(format === "DD:HH:MM:SS" ? timeRemaining.hours : timeRemaining.days * 24 + timeRemaining.hours, 'hours'), renderSeparator()] })), renderTimeUnit(timeRemaining.minutes, 'minutes'), renderSeparator(), renderTimeUnit(timeRemaining.seconds, 'seconds')] }));
};
CountdownFx.displayName = "CountdownFx";
export { CountdownFx };
//# sourceMappingURL=CountdownFx.js.map
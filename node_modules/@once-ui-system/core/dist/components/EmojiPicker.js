"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useCallback, useRef, useEffect, useId, memo, useMemo } from "react";
import { SegmentedControl, IconButton, Grid, Text, Input, Icon, Column, Row, } from ".";
import { useDebounce } from "../hooks/useDebounce";
import styles from "./EmojiPicker.module.scss";
const fallbackEmojiData = {
    smileys: [
        { char: "ðŸ˜€", description: "grinning face" },
        { char: "ðŸ˜ƒ", description: "grinning face with big eyes" },
        { char: "ðŸ˜„", description: "grinning face with smiling eyes" },
        { char: "ðŸ˜", description: "beaming face with smiling eyes" },
        { char: "ðŸ˜†", description: "grinning squinting face" },
        { char: "ðŸ˜…", description: "grinning face with sweat" },
        { char: "ðŸ¤£", description: "rolling on the floor laughing" },
        { char: "ðŸ˜‚", description: "face with tears of joy" },
    ],
    animals: [
        { char: "ðŸ¶", description: "dog face" },
        { char: "ðŸ±", description: "cat face" },
        { char: "ðŸ­", description: "mouse face" },
        { char: "ðŸ¦Š", description: "fox face" },
    ],
    food: [
        { char: "ðŸŽ", description: "red apple" },
        { char: "ðŸ", description: "pear" },
        { char: "ðŸŠ", description: "tangerine" },
        { char: "ðŸ‹", description: "lemon" },
    ],
    activities: [
        { char: "âš½", description: "soccer ball" },
        { char: "ðŸ€", description: "basketball" },
        { char: "ðŸˆ", description: "american football" },
        { char: "âš¾", description: "baseball" },
    ],
    travel: [
        { char: "ðŸš—", description: "car" },
        { char: "ðŸš•", description: "taxi" },
        { char: "ðŸš™", description: "sport utility vehicle" },
        { char: "ðŸšŒ", description: "bus" },
    ],
    objects: [
        { char: "ðŸ’»", description: "laptop" },
        { char: "ðŸ“±", description: "mobile phone" },
        { char: "ðŸ’¡", description: "light bulb" },
        { char: "ðŸ”", description: "magnifying glass" },
    ],
    symbols: [
        { char: "â¤ï¸", description: "red heart" },
        { char: "ðŸ’”", description: "broken heart" },
        { char: "ðŸ’¯", description: "hundred points" },
        { char: "âœ¨", description: "sparkles" },
    ],
    flags: [
        { char: "ðŸ", description: "chequered flag" },
        { char: "ðŸš©", description: "triangular flag" },
        { char: "ðŸŽŒ", description: "crossed flags" },
        { char: "ðŸ´", description: "black flag" },
    ],
};
import generatedEmojiData from "../data/emoji-data.json";
const emojiData = Object.keys(generatedEmojiData).length > 0
    ? generatedEmojiData
    : fallbackEmojiData;
const EmojiButton = memo(({ emoji, index, isFocused, onSelect, onFocus }) => {
    return (_jsx(IconButton, { tabIndex: index === 0 || isFocused ? 0 : -1, variant: "tertiary", size: "l", onClick: () => onSelect(emoji.char), "aria-label": emoji.description, title: emoji.description, className: styles.emojiButton, onFocus: () => onFocus(index), role: "gridcell", ref: isFocused ? (el) => el?.focus() : undefined, children: _jsx(Text, { variant: "heading-default-xl", children: emoji.char }) }, index));
});
EmojiButton.displayName = "EmojiButton";
const EmojiPicker = ({ onSelect, onClose, className, background, columns = "8", style, ...flex }) => {
    const searchInputId = useId();
    const [inputValue, setInputValue] = useState("");
    const searchQuery = useDebounce(inputValue, 300);
    const [activeCategory, setActiveCategory] = useState("smileys");
    const [focusedEmojiIndex, setFocusedEmojiIndex] = useState(-1);
    const gridRef = useRef(null);
    const getCategoryIcon = (category) => {
        switch (category) {
            case "smileys":
                return "smiley";
            case "animals":
                return "paw";
            case "food":
                return "food";
            case "activities":
                return "ball";
            case "travel":
                return "world";
            case "objects":
                return "gift";
            case "symbols":
                return "symbol";
            case "flags":
                return "flag";
            default:
                return "smiley";
        }
    };
    const categoryButtons = Object.keys(emojiData).map((category) => ({
        value: category,
        children: _jsx(Icon, { name: getCategoryIcon(category), size: "s" }),
    }));
    const handleEmojiSelect = useCallback((emoji) => {
        onSelect(emoji);
        if (onClose) {
            onClose();
        }
    }, [onSelect, onClose]);
    const handleCategoryChange = useCallback((value) => {
        setActiveCategory(value);
    }, []);
    const filteredEmojis = useMemo(() => searchQuery
        ? Object.values(emojiData)
            .flat()
            .filter((emoji) => emoji.description.includes(searchQuery.toLowerCase()))
        : emojiData[activeCategory] || [], [searchQuery, activeCategory]);
    // Reset focused index when filtered emojis change
    useEffect(() => {
        setFocusedEmojiIndex(-1);
    }, [filteredEmojis]);
    // Memoize the onFocus handler to prevent re-creating on every render
    const handleFocus = useCallback((index) => {
        setFocusedEmojiIndex(index);
    }, []);
    // Handle keyboard navigation
    const handleKeyDown = useCallback((e) => {
        if (filteredEmojis.length === 0)
            return;
        // Use provided columns prop for grid navigation
        const emojisPerRow = Number(columns) || 6;
        let newIndex = focusedEmojiIndex;
        switch (e.key) {
            case "ArrowRight":
                e.preventDefault();
                newIndex = focusedEmojiIndex < filteredEmojis.length - 1 ? focusedEmojiIndex + 1 : 0;
                break;
            case "ArrowLeft":
                e.preventDefault();
                newIndex = focusedEmojiIndex > 0 ? focusedEmojiIndex - 1 : filteredEmojis.length - 1;
                break;
            case "ArrowDown":
                e.preventDefault();
                newIndex = focusedEmojiIndex + emojisPerRow;
                if (newIndex >= filteredEmojis.length) {
                    // Wrap to the beginning of the appropriate column
                    newIndex = focusedEmojiIndex % emojisPerRow;
                    if (newIndex >= filteredEmojis.length)
                        newIndex = filteredEmojis.length - 1;
                }
                break;
            case "ArrowUp":
                e.preventDefault();
                newIndex = focusedEmojiIndex - emojisPerRow;
                if (newIndex < 0) {
                    // Wrap to the end of the appropriate column
                    const rowsCount = Math.ceil(filteredEmojis.length / emojisPerRow);
                    newIndex = (rowsCount - 1) * emojisPerRow + (focusedEmojiIndex % emojisPerRow);
                    if (newIndex >= filteredEmojis.length) {
                        newIndex = filteredEmojis.length - 1;
                    }
                }
                break;
            case "Enter":
            case " ":
                if (focusedEmojiIndex >= 0 && focusedEmojiIndex < filteredEmojis.length) {
                    e.preventDefault();
                    handleEmojiSelect(filteredEmojis[focusedEmojiIndex].char);
                }
                break;
            default:
                return;
        }
        setFocusedEmojiIndex(newIndex);
    }, [filteredEmojis, focusedEmojiIndex, handleEmojiSelect, columns]);
    return (_jsxs(Column, { gap: "16", background: background, className: className, style: style, "data-testid": "emoji-picker", height: 24, ...flex, children: [_jsx(Input, { id: `emoji-search-${searchInputId}`, placeholder: "Search emojis", value: inputValue, height: "s", onChange: (e) => setInputValue(e.target.value), hasPrefix: _jsx(Icon, { size: "s", onBackground: "neutral-weak", name: "search" }), "aria-label": "Search emojis" }), _jsx(Column, { tabIndex: -1, fillHeight: true, overflowY: "auto", overflowX: "hidden", children: filteredEmojis.length > 0 ? (_jsx(Grid, { gap: "2", fillWidth: true, columns: columns, "aria-label": searchQuery ? "Search results" : `${activeCategory} emojis`, ref: gridRef, onKeyDown: handleKeyDown, tabIndex: -1, role: "grid", children: filteredEmojis.map((emoji, index) => (_jsx(EmojiButton, { emoji: emoji, index: index, isFocused: index === focusedEmojiIndex, onSelect: handleEmojiSelect, onFocus: handleFocus }, index))) })) : (_jsx(Row, { fill: true, center: true, align: "center", onBackground: "neutral-weak", children: "No results found" })) }), !searchQuery && (_jsx(SegmentedControl, { buttons: categoryButtons, onToggle: handleCategoryChange, defaultSelected: activeCategory, fillWidth: true }))] }));
};
EmojiPicker.displayName = "EmojiPicker";
export { EmojiPicker };
//# sourceMappingURL=EmojiPicker.js.map